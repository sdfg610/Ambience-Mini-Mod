/* This file contains the Token specification and Grammar which COCO/R uses to construct the scanner
and parser. COCO/R uses Extend Bacus-Naur form (EBNF) for the grammar, as well as its own series of commands
which will be explained when met first in context.  */

// The scanner/lexer and parser files are created by inserting generated code (based on this .ATG file)
// into the "Scanner.frame" and "Parser.frame" files located alongside the Dims.ATG file.

/* The EBNF uses the following extensions: */
/* [] Brackets mean that the string is written zero or one times.  */
/* {} Curly brackets mean that the string is repeated zero or more times  */
/* () is a grouping used alongside |. The parenthesis contains a series of strings separated by |. This means that exactly one of the strings is chosen. */

/* Imports here are inserted at the top of the generated lexer and parser. */
import me.molybdenum.ambience_mini.engine.configuration.abstract_syntax.expression.*;
import me.molybdenum.ambience_mini.engine.configuration.abstract_syntax.config.*;
import me.molybdenum.ambience_mini.engine.configuration.abstract_syntax.schedule.*;
import me.molybdenum.ambience_mini.engine.configuration.abstract_syntax.playlist.*;
import me.molybdenum.ambience_mini.engine.configuration.errors.LoadError;
import me.molybdenum.ambience_mini.engine.configuration.errors.SynError;

import java.io.InputStream;
import java.util.ArrayList;

/* The required start of a Coco/R grammar file. "Program" specifies the starting symbol of the grammar. */
COMPILER File

/* Code here is injected at the start of the parser class. */
    Config mainNode = null; // This contains the AST generated by calling parser.Parse().

    private static String removeFirstAndLast(String str) {
        return str.substring(1, str.length() - 1);
    }

/*------------------------------------------------------------------------*/
/* The following section contains the token specification of Dims.*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  digit = "0123456789" .
  lf  = '\n' .
  stringChar = ANY - lf - '\r' - '"'.

TOKENS
  IDENT  = ('_' | letter) {letter | digit | '_'}  .
  INT    = ['-'|'+'] digit {digit}  .
  FLOAT  = ['-'|'+'] digit {digit} '.' digit {digit}  .
  STRING = '"' {stringChar} '"' .

COMMENTS FROM "/*" TO "*/" NESTED  /* Nested means: "There can be comments inside comments" */
COMMENTS FROM "//" TO lf

IGNORE '\r' + '\n' + '\t' /* These characters are ignored by the lexer */


/*------------------------------------------------------------------------*/
/* The rest of the file contains the grammar for Dims.  */
PRODUCTIONS

File = Conf<out mainNode> .

Conf<out Config conf>                (. conf = null; .)
    = "playlist" IDENT               (. IdentP ident = new IdentP(t.val, t.line); .)
      '=' Play<out Playlist play> ';'
      Conf<out Config inner>         (. conf = new PlaylistDecl(ident, play, inner); .)
    | Shed<out Schedule schedule>    (. conf = new ScheduleDecl(schedule); .)
.

/*------------------------------------------------------------------------*/
Play<out Playlist play>
     = PlayTerm<out play>
         { "++" PlayTerm<out Playlist play2> (. play = new Concat(play, play2); .)
         }
.

PlayTerm<out Playlist play>               (. play = new Nil(); FloatLit gain = null; .)
    = '['
        [ PlayTerm<out Playlist load>     (. play = load;      .)
          { ',' PlayTerm<out load>        (. play = new Concat(play, load); .)
          }
        ]
      ']'
    | IDENT                         (. play = new IdentP(t.val, t.line); .)
    | "NIL"
    | STRING                    (. StringLit file = new StringLit(removeFirstAndLast(t.val)); int line = t.line; .)
            [ '<' (FLOAT|INT)   (. gain = new FloatLit(Float.parseFloat(t.val));            .)
              '>'
            ]                   (. play = new Load(file, gain, line);                           .)
.

/*------------------------------------------------------------------------*/
Shed<out Schedule schedule>                  (. schedule = null; boolean instant = false; .)
    = "play" ["instant"                      (. instant = true; .)
      ] Play<out Playlist pl> ';'            (. schedule = new Play(pl, instant); .)
//    | "print" Expr<out Expr expr>            (. ArrayList<Shed> exprs = new ArrayList<>(); exprs.add(expr); .)
//      { ',' Expr<out expr>                   (. exprs.add(expr); .)
//      } ';'                                  (. shed = new Print(exprs); .)
    | "begin"                                (. ArrayList<Schedule> items = new ArrayList<>();  .)
      { Shed<out Schedule schedule2>         (. items.add(schedule2); .)
      }
      "end"                                  (. schedule = new Block(items); .)
    | "when"                                   (. int line = t.line; .)
      '(' Expr<out Expr expr>
      ')' Shed<out Schedule schedule2>         (. schedule = new When(expr, schedule2, line); .)
    | "default"                      (. int line = t.line; .)
      Shed<out Schedule schedule2>   (. schedule = new When(new BoolLit(true), schedule2, line); .)
    | "interrupt"                       (. int line = t.line; .)
      Shed<out Schedule schedule2>      (. schedule = new Interrupt(schedule2, line); .)
.

/*------------------------------------------------------------------------*/
Expr<out Expr expr>              (. BinaryOperators op = BinaryOperators.AND; int line = -1; .)
    = ExprEq<out expr>
    { ( "&&"                     (. op = BinaryOperators.AND; line = t.line; .)
      | "||"                     (. op = BinaryOperators.OR; line = t.line; .)
      ) ExprEq<out Expr expr2>   (. expr = new BinaryOp(op, expr, expr2, line); .)
    }
.

ExprEq<out Expr expr>            (. BinaryOperators op = BinaryOperators.EQ; int line = -1; .)
    = ExprRel<out expr>
    { ( "=="                     (. op = BinaryOperators.EQ; line = t.line; .)
      | "~~"                     (. op = BinaryOperators.APP_EQ; line = t.line; .)
      ) ExprRel<out Expr expr2> (. expr = new BinaryOp(op, expr, expr2, line); .)
    }
.

ExprRel<out Expr expr>            (. BinaryOperators op = BinaryOperators.EQ; int line = -1; .)
    = ExprTerm<out expr>
    { ( "<"                     (. op = BinaryOperators.LT; line = t.line; .)
      ) ExprTerm<out Expr expr2> (. expr = new BinaryOp(op, expr, expr2, line); .)
    }
.

ExprTerm<out Expr expr> (. expr = null; Quantifiers quantifier = Quantifiers.ANY; .)
    = IDENT             (. expr = new IdentE(t.val, t.line);                      .)
    | INT               (. expr = new IntLit(Integer.parseInt(t.val));      .)
    | FLOAT             (. expr = new FloatLit(Float.parseFloat(t.val));    .)
    | STRING            (. expr = new StringLit(removeFirstAndLast(t.val)); .)
    | "true"            (. expr = new BoolLit(true);                        .)
    | "false"           (. expr = new BoolLit(false);                       .)
    | '@' IDENT         (. expr = new GetEvent(new IdentE(t.val, t.line));    .)
    | '$' IDENT         (. expr = new GetProperty(new IdentE(t.val, t.line)); .)
    | ("any" | "all"    (. quantifier = Quantifiers.ALL; .)
      ) IDENT           (. String identifier = t.val; int line = t.line; .)
      "in"                        (. int inLine = t.line; .)
      Expr<out Expr list> "where" (. int whereLine = t.line; .)
      Expr<out Expr cond> "end"
                        (. expr = new QuantifierOp(quantifier, new IdentE(identifier, line), list, cond, inLine, whereLine); .)
    | '(' Expr<out expr> ')'
.

END File. // Must refer to the same non-terminal as "COMPILER" at the top.