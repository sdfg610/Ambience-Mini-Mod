/* This file contains the Token specification and Grammar which COCO/R uses to construct the scanner
and parser. COCO/R uses Extend Bacus-Naur form (EBNF) for the grammar, as well as its own series of commands
which will be explained when met first in context.  */

// The scanner/lexer and parser files are created by inserting generated code (based on this .ATG file)
// into the "Scanner.frame" and "Parser.frame" files located alongside the Dims.ATG file.

/* The EBNF uses the following extensions: */
/* [] Brackets mean that the string is written zero or one times.  */
/* {} Curly brackets mean that the string is repeated zero or more times  */
/* () is a grouping used alongside |. The parenthesis contains a series of strings separated by |. This means that exactly one of the strings is chosen. */

/* Imports here are inserted at the top of the generated lexer and parser. */
import gsto.ambience_mini.music.loader.abstract_syntax.expr.*;
import gsto.ambience_mini.music.loader.abstract_syntax.conf.*;
import gsto.ambience_mini.music.loader.abstract_syntax.shed.*;
import gsto.ambience_mini.music.loader.abstract_syntax.play.*;
import java.util.ArrayList;

/* The required start of a Coco/R grammar file. "Program" specifies the starting symbol of the grammar. */
COMPILER File

/* Code here is injected at the start of the parser class. */
    public Conf mainNode = null; // This contains the AST generated by calling parser.Parse().

    public boolean hasErrors() {
        return errors.count > 0;
    }

    private static String removeFirstAndLast(String str) {
        return str.substring(1, str.length() - 1);
    }

    private Expr makeEqOp(String op, Expr left, Expr right)
    {
        return switch (op) {
            case "==" ->  new BinaryOp(BinaryOperators.EQ, left, right);
            case "~~" -> new BinaryOp(BinaryOperators.APP_EQ, left, right);
            default -> throw new RuntimeException("Unknown equality operator: " + op);
        };
    }

/*------------------------------------------------------------------------*/
/* The following section contains the token specification of Dims.*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  digit = "0123456789" .
  lf  = '\n' .
  stringChar = ANY - lf - '\r' - '"'.

TOKENS
  IDENT  = ('_' | letter) {letter | digit | '_'}  .
  INT    = ['-'|'+'] digit {digit}  .
  FLOAT  = ['-'|'+'] digit {digit} '.' digit {digit}  .
  STRING = '"' {stringChar} '"' .

COMMENTS FROM "/*" TO "*/" NESTED  /* Nested means: "There can be comments inside comments" */
COMMENTS FROM "//" TO lf

IGNORE '\r' + '\n' + '\t' /* These characters are ignored by the lexer */


/*------------------------------------------------------------------------*/
/* The rest of the file contains the grammar for Dims.  */
PRODUCTIONS

File = Conf<out mainNode> .

Conf<out Conf conf>                (. conf = null; .)
    = "playlist" IDENT             (. IdentP ident = new IdentP(t.val); .)
      '=' Play<out PL play> ';'
      Conf<out Conf inner>         (. conf = new Playlist(ident, play, inner); .)
    | Shed<out Shed shed>          (. conf = new Schedule(shed); .)
.

/*------------------------------------------------------------------------*/
Play<out PL play>
     = PlayTerm<out play>
         { "++" PlayTerm<out PL play2> (. play = new Concat(play, play2); .)
         }
.

PlayTerm<out PL play>               (. play = new Nil(); FloatV gain = null; .)
    = '['
        [ PlayTerm<out PL load>     (. play = load;      .)
          { ',' PlayTerm<out load>  (. play = new Concat(play, load); .)
          }
        ]
      ']'
    | IDENT                         (. play = new IdentP(t.val); .)
    | "NIL"
    | STRING                    (. StringV file = new StringV(removeFirstAndLast(t.val)); .)
            [ '<' (FLOAT|INT)   (. gain = new FloatV(Float.parseFloat(t.val));            .)
              '>'
            ]                   (. play = new Load(file, gain);                           .)
.

/*------------------------------------------------------------------------*/
Shed<out Shed shed>                    (. shed = null; .)
    = "play" Play<out PL pl> ';'       (. shed = new Play(pl); .)
    | "begin"                          (. ArrayList<Shed> items = new ArrayList<>();  .)
      { Shed<out Shed shed2>           (. items.add(shed2); .)
      }
      "end"                            (. shed = new Block(items); .)
    | "when" '(' Expr<out Expr expr>
      ')' Shed<out Shed shed2>         (. shed = new When(expr, shed2); .)
    | "default" Shed<out Shed shed2>   (. shed = new When(new BoolV(true), shed2); .)
    | "interrupt" Shed<out Shed shed2> (. shed = new Interrupt(shed2); .)
.

/*------------------------------------------------------------------------*/
Expr<out Expr expr>              (. String op = null; .)
    = ExprTerm<out expr>
    { ( "=="                     (. op = "=="; .)
      | "~~"                     (. op = "~~"; .)
      ) ExprTerm<out Expr expr2> (. expr = makeEqOp(op, expr, expr2); .)
    }
.

ExprTerm<out Expr expr> (. expr = null;                                   .)
    = IDENT             (. expr = new IdentE(t.val);                      .)
    | INT               (. expr = new IntV(Integer.parseInt(t.val));      .)
    | FLOAT             (. expr = new FloatV(Float.parseFloat(t.val));    .)
    | STRING            (. expr = new StringV(removeFirstAndLast(t.val)); .)
    | "true"            (. expr = new BoolV(true);                        .)
    | "false"           (. expr = new BoolV(false);                       .)
    | '@' IDENT         (. expr = new Event(new IdentE(t.val));           .)
    | ':' IDENT         (. expr = new Get(new IdentE(t.val));             .)
.

END File. // Must refer to the same non-terminal as "COMPILER" at the top.